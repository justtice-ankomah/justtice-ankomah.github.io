
STYLES::
They are attribute that can be assigned to views like Button, Textview to display how it will look. Every view can have only one style, but a single style can be applied to multiple views. 
When a style is applied to a view, the view will accept only the attribute it needs and ignore the other attribute in the style.  

format to creat a style::

<style name="styleName" parent="parent class to inherit from. you can remeove this">   
      <item name="android view attribute key here">value here</item>      
</style>

Format to apply a style to view in xml::
   <Button
      android:id="@+id/mybtn"
      style="@style/mystyleName"/>

THEMES::
Themes are applied to single activity or all the application activities. You can't apply theme to a view becuase the attributes in it are windows attribute not views.

To apply it to all application activities, inside Manifest.xml add android:theme="@style/themeName" to   <application> attribute.
To apply it to a single activity, inside the manifest.xml add android:theme="@style/themeName" to the <activity> attribute.

======================================================================

TOOLBAR AND MENUS::

Android have 3 Menus: 
   1. Option Menu
    2. context menu
    3. popup menu
To have a static actionBar that will contain only icon and back arrow, safely use actionBar. To have dynamic actionbar that you can customize yourself use Toolbar.

1. Make sure the toobar dependency is added to your graddle file.  
implementation 'androidx.appcompat:appcompat:1.0.0'

2. disable the theme ActionBar to Theme.AppCompat.Light.NoActionBar, in your style file where your them is.

3. Creat a seperate xml layout file to hold your toobar and include it in other activies xml where you want to display it.
   <linearlayout
    android:orientation="vertical"
    android:fitsSystemWindows="true">

       <androidx.appcompat.widget.Toolbar/>
   </linearlayout>
Note: You have to add android:fitsSystemWindows="true" to the parent layout of the Toolbar to ensure that the height of the activity is calculated correctly. 

4. Next, in your Activity or Fragment, find the id of the Toolbar and then, set the Toolbar to act as the ActionBar by calling the setSupportActionBar(Toolbar) method, remember the parameter is the object of the toolbar id:
          :::ADDING OPTION MENU TO Toolbar
5. create a menu items in res/menu/mymenu.xml and inflate it to the toolbar. this is the items that will show in the toolbar.
 
<menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/miCompose"
        android:icon="@drawable/ic_compose"
        app:showAsAction="ifRoom"
        android:title="Compose">
    </item>
 
</menu>

An activity 0nCreateOptionsMenu() method add items to the action Appbar if is present. inflating the above menu to the toobar

public class MainActivity extends AppCompatActivity {
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.menu_main, menu); 
        return true;
    }
}
 
6.handle clicks in activity overide method "onOptionsItemSelected()" when the munuitems in the toolbar are clicked::

@Override
public boolean onOptionsItemSelected(MenuItem item) {
    // Handle presses on the action bar items
    switch (item.getItemId()) {
        case R.id.miCompose:
            composeMessage();
            return true;
            break
    }
}

So simple ==create a seperate xml file to hold your toolbar and inflate it into activities you want to show it in with 0nCreateOptionsMenu() AND handle menu clicks with onOptionsItemSelected();

======================================================================

** HOW TO ADD BACK ICON BUTTON TO THE APPBAR
 
  1. The appbar back arrow is set to false by defualt. Set it to true to dispaly it with:

     getSupportActionBar().setDefaultDisplayHomeAsUpEnabled(true);

 2. Inside manifest.xml set the parent activity the back arrow should navigate to when clicked by adding this to the activity xml attribute with::

 Tell the current activity which activity should navigate to when back arrow icon is clicked, by adding this to the current activiy xml attribute in the manifest.xml: 

 android:parentActivityName="Activity Name"

======================================================================

** BOTTOM NAVIGATION

1. Add a BottomNavigationView to your activity.xml with an ID and create a new menu item in Menu directory and add it to the bottom navigation with   app:menu="@menu/menuName"

2. Get the object of the Navigation Bottom in your mainActivity.java and handle clicks of menu items with:

mybottomnav = (BottomNavigationView)

   mybottomnav.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(@NonNull MenuItem item) { 
           //handle clicks
        return true;
        }
        });


ANDROID SQL LITE::
just like mysql database but it does not need any connection.

To use it::

create a class that extends "android sqllite" and implement it 2 methods that is "oncreate" and "onUpgreade" then create a constuctor for your class;
Inside the "oncreate" method is where you create your tables;
Inside the "onUpgreade" method is where you should do modification to your table;
the contructor is for creating the database. 

To insert values into a specific table use this format::
ContentValues cv = new ContentValues();
cv.put(colum_name,value);
cv.put(colum_name,value);
SQLiteDatabase db = getWritableDatabase();
db.insert(table_name,null, cv);
db.close();

TO DELETE A ROW USE:::
SQLiteDatabase db = getWritableDatabase();
db.execSQL("delete bookname for table books where id = 2;");


To SELECT A VALUES IN A TABLE:::
SQLiteDatabase db = getWritableDatabase();
String query = "select * from books where bookid=1";
Cursor cursor = db.rewQuery(query,null);

cursor.moveTofirst();
while(!cursor.isAfterLast()){
String value = cursor.getString(cursor.getColumnIndex("table culume here"));

}
db.close

========================

To surpport service binding,

implements the "OnBind" method and return the instance of the service class:

@overide
public IBinder onBind(Intent intent){
   return binder;
}

puplic class mybinder extend Binder{
 myservice get(){
   return myserservice.this;
 }
}

public IBinder binder = new mybinder();

IBinder, OnBind, Binder

1. create a public inner class that extends Binder, and create a method in it that return the instance of the parent class (Service);

2. create create and Ibinder oject of this inner class;

3. return this Ibinder object in "onbind" method.


Then..
To bind to this service inside your mainactivity:::

declare an object of your service class but don't assign anything to it. the key is to assign the instance of your service class to it in the "onServiceConnected" of the serviceconnection.

Myservice myservice_obj; 

Then setpup a service connection.Inside "onServiceConnected" cast the (IBinder service) to your service innerclass. Then use that object to  assign Myservice class instance to the myservice_obj above;


    ServiceConnection serviceConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            Myservice.mybinder mybinder_obj = (Myservice.mybinder) service;
          myservice_obj = mybinder_obj.getService();
          
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
         

        }
    };

Now you have gotten an objct of your Myservice class that is "myservice_obj" You can now use it to retrive methods in the service

======
1. When an activity asks to bind to a service using a service connection, the connection calls the onBind() method of  the service

2. an activity binds to a service using a ServiceConnection object. A ServiceConnection is an interface with two methods: onServiceConnected() and onServiceDisconnected(). 


3,. The onServiceConnected() method is called when a connection to the service has been established and a Binder object is received from the service

4. onServiceDisconnected() method is used when the connection to the service has been lost




 